Great. I‚Äôll prepare a full-stack technical implementation plan for the Kwiaty Teresy e-commerce platform. This will be broken down into detailed sections covering the frontend with Next.js, backend architecture with Django, database schema design with PostgreSQL, AI agent integration using Flowise, messaging infrastructure, deployment setup, compliance and security considerations, and extensibility for future growth.

I‚Äôll align every technical recommendation with the brand‚Äôs core identity: preserving the artisanal, heartfelt touch of Teresa‚Äôs flower delivery service while building a modern, scalable system. I‚Äôll let you know once it‚Äôs ready.


# Full-Stack Implementation Plan for Kwiaty Teresy E-commerce Platform

**Overview:** This plan outlines a component-by-component implementation for **Kwiaty Teresy**, an artisan flower boutique‚Äôs online system. The goal is to blend modern e-commerce efficiency with Teresa‚Äôs personal, caring touch. Each technical decision considers reliability, ease of use, and the warm brand voice that makes customers feel they‚Äôre dealing with a neighborhood florist rather than a faceless app.

## 1. Frontend (Next.js)

**Tech & Framework:** Use **Next.js (React)** to build a fast, SEO-friendly web frontend. This provides server-side rendering (SSR) for search engine indexing (crucial for queries like ‚Äúflower delivery in Katowice‚Äù) and a smooth client-side experience once loaded. We will structure the app as a **mobile-first**, responsive design to cater to on-the-go customers.

* **Page Structure & Routing:**

  * **Homepage:** A welcoming landing page featuring a hero section with Teresa‚Äôs story or a warm greeting. It highlights a few signature bouquets or seasonal specials. Include quick links (e.g., *Shop by Occasion*, *Best Sellers*, *Seasonal Highlights*).
  * **Product Listing Pages:** Pages for categories like *All Bouquets*, or *By Occasion* (Birthday, Anniversary, etc.). These will list products in a grid of cards with images, names, and prices. We‚Äôll use Next.js dynamic routing for category pages (e.g., `/occasions/[slug].js` for each occasion).
  * **Product Detail Page:** A rich page for each bouquet/arrangement. It will show a gallery of photos, description, options (size selection, add-ons, etc.), price, and an **‚ÄúAdd to Cart‚Äù** or **‚ÄúBuy Now‚Äù** button. Also display *seasonal availability* notes (e.g., ‚ÄúAvailable May‚ÄìAugust‚Äù) if applicable, and a reminder like ‚ÄúIncludes a free handwritten card‚Äù. Use Next‚Äôs `[id].js` route or new App Router with generateStaticParams if pre-rendering products. Use SSR (`getServerSideProps`) to fetch product details so that meta tags (title, description with flower names and city) are SEO-optimized.
  * **Cart & Checkout Pages:** A multi-step checkout (`/checkout` with sub-steps or modals). Step 1: Review cart items; Step 2: Enter Sender info & Recipient delivery details; Step 3: Delivery date/time selection (with an interactive calendar component showing available dates); Step 4: Message composition (with an optional *‚ÄúGenerate message‚Äù* AI helper button); Step 5: Payment. We will structure this either as a single dynamic page that shows sub-components for each step (using local state or query params to track progress), or separate routes (`/checkout/delivery`, `/checkout/payment`, etc.) for clarity.
  * **Order Confirmation Page:** After checkout, show an order summary with a friendly thank-you note (e.g., ‚ÄúDziƒôkujemy! Your order is confirmed, Teresa will craft your bouquet with love.‚Äù). If the user has an account, provide a link to *track status* (or status could simply show here and auto-update if we use real-time updates). For guests, display an order number and perhaps offer an account signup to track future orders.
  * **About/Story Page:** A dedicated page telling Teresa‚Äôs story, philosophy, and perhaps a photo of her at work. This reinforces the personal brand. Content managed via the CMS/admin for easy editing.
  * **Contact/Support Page:** Page with contact info, a query form, and possibly the live chat widget entry point. Include store phone number and an embedded Google Map if a physical shop address is relevant.
  * **Inspirations/Gallery/Blog:** (Optional) A section to showcase Instagram feed or blog posts (e.g., ‚ÄúFloral tips‚Äù, ‚ÄúBehind the scenes‚Äù). This can be a static page with an embedded IG feed or a dynamic blog listing if Teresa writes posts. Use SSR or Incremental Static Regeneration (ISR) for blogs for SEO, and allow managing posts via the backend.

* **Components and UI Design:**

  * Build reusable **React components** for the UI: e.g., `ProductCard`, `ProductGallery`, `CartItem`, `DatePicker`, `TimeSlotSelector`, etc. A `NavBar` with the boutique name and a floral logo should appear on top, and a persistent `Footer` with contact info, social media (Instagram link), and trust badges (SSL, payment logos) at bottom.
  * **Styling:** Use **Tailwind CSS** for a consistent, quick-to-develop styling approach. Tailwind‚Äôs utility classes will enforce a **mobile-first** design (styles apply to small screens by default, with responsive prefixes for larger screens). Define a custom color palette reflecting the brand (e.g., soft pastel pinks, creams, greens inspired by flowers and foliage). Tailwind will allow rapid UI tweaks as we iterate based on Teresa‚Äôs feedback, ensuring the site feels handcrafted yet professional.
  * Ensure the visual design has *warmth*: use plenty of flower imagery and maybe a cursive or elegant font for headings (while keeping body text highly readable). Small touches like a floral illustration in the header background or on section dividers can convey the boutique‚Äôs artisan feel. However, keep the layout clean and uncluttered, letting the images and heartfelt copy shine.
  * **State Management:** Leverage React‚Äôs built-in context or lightweight state libraries for global state (e.g., cart context, user session). Next.js 13 with the App Router can also manage state via React context easily across server and client components. Use client-side logic sparingly for critical UX (like form validation or dynamic form steps), while heavier data (product lists, etc.) comes via SSR/initial props.
  * **Interactive Elements:** Include a **chatbot widget** (for the AI concierge) accessible via an icon (e.g., a chat bubble saying ‚ÄúNeed help choosing? üôÇ‚Äù). This can be a fixed bottom-right component that expands into a chat window. The chat UI should be friendly ‚Äì use the brand voice (‚ÄúHi, I‚Äôm Teresa‚Äôs assistant! How can I help you find the perfect flowers?‚Äù). Implement it as a React component that calls the backend/AI API (more on that in the AI integration section).
  * For **real-time updates**, use a WebSocket or polling on pages like Order Tracking. For example, on the Order Confirmation page (or a separate *Track Order* page), we might open a WebSocket connection to listen for status updates (‚Äúprepared‚Äù, ‚Äúout for delivery‚Äù, ‚Äúdelivered‚Äù). On receiving an update, the UI can show a nice status timeline with checkmarks. If WebSockets are complex to integrate initially, use periodic polling (e.g. every 30 seconds hit an `/order/status` endpoint) ‚Äì but the goal is to eventually have *instant, live feedback* to mimic how Teresa might call or text when she‚Äôs on the way.

* **SEO and Accessibility:**

  * Implement server-side rendering for all main pages and use descriptive, keyword-rich content to boost **local SEO**. For example, the homepage `<title>` could be ‚ÄúKwiaty Teresy ‚Äì Artisan Flower Delivery in Katowice with a Personal Touch‚Äù, and occasion pages could include city/region names. Include meta descriptions that emphasize the hand-crafted aspect (‚ÄúEach bouquet is made with love by Teresa and delivered by hand, across Silesia‚Äù).
  * Use Next.js‚Äôs `<Head>` component to manage meta tags on each page (unique titles, descriptions, Open Graph tags for social sharing with a pretty bouquet image). Also, generate a dynamic sitemap and RSS if needed for blog posts. We‚Äôll integrate **structured data** (JSON-LD) for products and local business info: e.g., schema for each product (name, image, price, availability) so Google can display rich results; and LocalBusiness schema on the About or Contact page with the shop‚Äôs details (address, opening hours).
  * Ensure high performance: optimize images (use Next Image for automatic responsive thumbs), compress and lazy-load where appropriate (e.g., load below-the-fold images as user scrolls). A fast site not only improves SEO ranking but also gives a smooth user experience (especially important for mobile users who might be on slower networks).
  * **Accessibility:** Follow WCAG guidelines ‚Äì use semantic HTML (landmarks, proper heading hierarchy), alt text for all images (describe bouquets and note they are from Kwiaty Teresy), and keyboard-navigable components. This not only broadens our audience (customers of all abilities) but also aligns with the caring ethos of the brand (being considerate and inclusive).
  * **Mobile-First Layout:** Starting designs on small screens ensures critical information is upfront. The site will use a single-column layout on phones: large images, easy-to-read text, and big touch-friendly buttons (e.g., ‚ÄúAdd to Cart‚Äù spans full width on mobile for easy tapping). We‚Äôll implement sticky elements like a bottom bar on product pages (‚ÄúAdd to Cart‚Äù always visible at bottom on mobile). On larger screens, we can enhance with multi-column layouts, hover effects for product cards, etc., but none of those will be required to use the site. The mobile checkout flow will be streamlined: minimal typing, use of autofill features (e.g., HTML5 input types for email, telephone, etc.), and perhaps integration with address auto-complete to reduce typing address on a phone.

Overall, the Next.js frontend will **feel like a friendly boutique in a web app form** ‚Äì visually inviting, easy to navigate, and responsive. It balances *artistry* (beautiful images, personal text) with *usability* (clear calls to action, straightforward forms), ensuring customers feel the human touch behind the technology.

## 2. Backend (Django + Django REST Framework)

**Tech Stack:** Use **Django** (Python) as the core backend for its robust features and secure framework. Layer **Django REST Framework (DRF)** on top to expose a clean **RESTful API** consumed by the Next.js frontend. This headless approach keeps frontend and backend decoupled, enabling future expansion (like a mobile app) and clear separation of concerns.

* **Data Models (Django Models):** Design intuitive models to capture Teresa‚Äôs business entities, ensuring each aligns with e-commerce needs and the artisanal workflow:

  * **Product (Bouquet) Model:** Fields for name, description, price, and an optional category or occasion (e.g., a ManyToMany to an `Occasion` model or a simple choice field: Birthday, Romance, Sympathy, etc.). Include a Boolean for `is_active` or `is_available` (so Teresa can hide sold-out or seasonal items easily), and maybe fields for `available_start` and `available_end` dates for seasonal offerings. Add an `image` field (or multiple images via a related `ProductImage` model if multiple angles of bouquets are shown). We also incorporate a field for **size/variant** if bouquets come in sizes (perhaps a choice: Standard, Deluxe, etc., with a price multiplier or separate price field per size). Each product can have a `slug` for SEO-friendly URLs.
  * **Customer/User Model:** Use Django‚Äôs built-in `User` for accounts (enabling login, password management). Extend it via a Profile model or custom User model to store additional info like phone number and a **loyalty points** or **order count** field for the loyalty program. We‚Äôll track how many orders a user has placed or points earned, enabling rewards (e.g., after 5 orders, an automatic discount or free bouquet on birthday). GDPR compliance note: ensure we can handle user data deletion if requested, and store only necessary personal data.
  * **Recipient/Address Model:** Because many orders are gifts, the recipient is often not the user. We separate this information for clarity. For each Order, we‚Äôll store recipient name, delivery address, and phone. We can model this either as plain fields on the Order (simple approach) or as a separate `Recipient` model that an order links to (if we want to save recipients for reuse). To support features like saved recipient lists for a user, we might create a `Recipient` model with fields (name, address, phone, maybe a user foreign key for the sender if they want to save it). This allows returning customers (logged in) to pick from their address book of past recipients at checkout. If implementing saved addresses, also include a boolean for ‚Äúis\_self‚Äù or type of recipient to differentiate between user‚Äôs own address vs others.
  * **Order Model:** Core model capturing each purchase and delivery request. Key fields:

    * ForeignKey to `User` (nullable for guest checkouts, or we create a placeholder user for guests).
    * ForeignKey to `Product` (or if an order can have multiple items, we use an `OrderItem` sub-model. Likely allow multiple items in one order ‚Äì e.g., bouquet + add-on gift ‚Äì so design an `Order` header with total, and `OrderItem` with quantity and product).
    * Delivery details: recipient name/address/phone (if not using separate Recipient model), and the chosen `delivery_date` and possibly `delivery_time_slot` (e.g., a choice field or text like ‚ÄúMorning (9-12)‚Äù if we define slots, or exact time if we allow exact scheduling).
    * `card_message` text field for the personalized message. Limit e.g. 500 characters and store as TextField.
    * `special_instructions` text field for any delivery notes (optional).
    * `status` field (choices: Pending, Confirmed, Preparing, Out-for-Delivery, Delivered, etc.). Default to Pending/Confirmed when first placed. Teresa can update this status in the admin as she progresses (triggering notifications).
    * `payment_status` or `payment_method`: indicate if paid online or to be paid on delivery. For online paid orders, also store a transaction ID or reference from the payment gateway (Stripe charge ID etc.) and a boolean `is_paid`. For cash-on-delivery orders (if allowed), `is_paid` would be false initially and marked true when cash is collected (which Teresa can update in admin).
    * Timestamps for `created_at` and `updated_at` (Django gives these easily). Possibly a `delivered_at` timestamp for actual delivery time logging.
    * If in future we have multiple florists, we could include a ForeignKey to a `Florist` or `Artisan` user who is responsible for this order (for now, implicitly Teresa for all). (We‚Äôll elaborate on extensibility later, but we keep the model flexible).
  * **OrderItem Model (if multi-item orders):** Link to Order (FK) and Product (FK), quantity, chosen variant (could be a field if product has variants like size), and line price. Alternatively, simplify by treating each Order as one bouquet plus optional add-ons; but supporting a cart of multiple items is more standard and flexible (e.g., a customer might order two different bouquets in one go).
  * **Occasion/Category Models:** To facilitate browsing by occasion or type, define simple models for categories (e.g., `Occasion` with name like ‚ÄúBirthday‚Äù, ‚ÄúSympathy‚Äù) and maybe a `Tag` model (like ‚ÄúRoses‚Äù, ‚ÄúSpring‚Äù, etc. for internal tagging). Products can ManyToMany to these for classification. This helps the frontend populate filters (‚ÄúShop by Occasion‚Äù menu) and also the AI concierge could use these tags to recommend items.
  * **Loyalty & Promotions:** If implementing a loyalty program, we might add a `LoyaltyTransaction` model to record points earned/redeemed per order, or simply store a points balance on the User profile updated after each order. For promotions, a simple `Coupon` model could exist (code, discount value, expiry) and an `Order.coupon` field if we want discount codes (not mentioned in prompt explicitly, but easy to add for marketing flexibility).

* **API Endpoints (Django REST Framework views/serializers):**
  We will create a **RESTful API** that the Next.js frontend interacts with for all dynamic data. Important endpoints include:

  * `GET /api/products/` ‚Äì List of active products (with filters for category/occasion). Supports search by keyword (e.g., flower type) to aid the concierge bot or site search. Serializer will include all details needed for display (name, price, image URLs, availability). Use pagination or limit as needed for performance.
  * `GET /api/products/{id}/` ‚Äì Detail of a specific product (full description, additional images, recommended related products maybe).
  * `GET /api/occasions/` ‚Äì List occasions (to populate filters or menus).
  * `POST /api/cart/` ‚Äì (If we handle cart server-side) Accepts product IDs and quantities to create a cart server-side. However, since Next.js can manage cart state client-side until checkout, we might not need a server cart model ‚Äì instead, the client can post the final order with items. So more likely:
  * `POST /api/orders/` ‚Äì Create a new Order. The payload includes customer info, recipient info, delivery date/time, message, and cart items. The view will authenticate the user (if logged in) or treat as guest. It will perform validations: e.g., check delivery date is available (not past cutoff or fully booked), calculate delivery fee, total price, and attempt payment if online payment is immediate. We might integrate with Stripe‚Äôs API here: e.g., Next.js could fetch a Payment Intent client secret from an endpoint, or redirect to a Stripe Checkout session. For simplicity, use Stripe‚Äôs client integration with a secure token from backend. Only create the Order in the database after payment success (or immediately and mark as pending payment, then update on webhook).
  * `GET /api/orders/{id}/` ‚Äì Retrieve an order (for status tracking). If the user is logged in, they can fetch their own orders. If a guest wants to check status, we might implement a secret lookup (like a unique tracking link with a UUID in email). Alternatively, require login for tracking, encouraging account creation. The response will include status and any updates (e.g., ‚ÄúOut for delivery at 14:30‚Äù).
  * `PATCH /api/orders/{id}/status` ‚Äì (Secured for admin or staff) Update the status of an order. This is for internal use when Teresa marks an order as delivered, etc. Instead of exposing this publicly, we‚Äôll likely just use Django Admin or a staff interface. But we can create internal API endpoints to support a custom admin UI or future mobile staff app.
  * **Authentication Endpoints:** Use Django REST Framework‚Äôs token auth or JWT for login. For example, `POST /api/auth/login/` (user provides email/password, get token or session cookie), `POST /api/auth/register/` (create account), `POST /api/auth/logout/`. We‚Äôll likely use **JWT (JSON Web Tokens)** with DRF SimpleJWT or similar, because the frontend is separate ‚Äì JWT allows stateless auth and easier integration with a mobile app later. The token is stored securely (HTTP-only cookie or memory) on the client. We must protect sensitive endpoints (like posting orders tied to an account) with auth, but allow public read access for products.
  * **User Profile Endpoints:** e.g., `GET /api/users/me/` ‚Äì to fetch user info and loyalty points, saved recipients, etc. `PUT /api/users/me/` to update details. Also endpoints for saved addresses or recipients if we implemented that (e.g., `GET /api/recipients/`, `POST /api/recipients/` for managing an address book).
  * **AI Endpoints:** (Integrating with Flowise/AI ‚Äì see AI section for detail, but listed here for completeness)

    * `POST /api/ai/message-suggest/` ‚Äì Secure endpoint that accepts context (occasion, relationship or a few words about what the sender wants to say) and returns a few generated message suggestions for the card. The backend will call the AI agent and return suggestions. We‚Äôll wrap this to ensure it‚Äôs fast and error-handled, so the checkout UI can quickly display the ideas.
    * `POST /api/ai/concierge-chat/` ‚Äì Endpoint for the chat widget to send user messages and receive the AI‚Äôs reply. It will pass the message to the Flowise chatbot agent and stream or return the response. We can maintain a session ID to keep context in the conversation (or let Flowise handle conversation memory).
    * (Alternatively, the chatbot could connect via WebSocket or direct to Flowise server, but an API endpoint gives us control over auth and monitoring).
    * Note: These AI endpoints will enforce rate limiting and possibly require the user to solve a simple anti-bot challenge if we fear misuse, since they connect to costly AI resources.

* **Business Logic & Services:**

  * Implement **delivery date validation logic** in the order creation view: when a new order is requested, the backend checks if the date is available. We will use the database to count how many deliveries are already scheduled that day. For example, if Teresa can handle 5 deliveries/day, and 5 orders exist for that date, the API will reject or suggest an alternate date. We may maintain a simple table or function to track daily capacity (e.g., each Order on a date increments a counter). For same-day orders, enforce cutoff times: the view can check `if requested_date == today and current_time > cutoff_hour: reject`. All these rules ensure we don‚Äôt promise what Teresa can‚Äôt deliver, preserving trust.
  * **Delivery fee calculation:** likely a function based on address or distance. For now, maybe a flat fee for the city and an extra fee per km outside a radius. This logic can use postal code or if we integrate Google Maps API on backend, calculate distance from shop to destination (if PostGIS is used, do a quick geo distance). The view will compute the fee and add it to the order total. Make sure the fee and any tax are clearly itemized in the response so the frontend can display them.
  * **Notifications dispatch:** When order status changes, the backend (or a signal handler in Django) will trigger sending emails/SMS (see Messaging section). We can utilize Django‚Äôs signal framework: e.g., an `post_save` on Order that if `status` changed to ‚ÄúOut for Delivery‚Äù or ‚ÄúDelivered‚Äù, it calls a notification function. This separates notification logic from view logic.
  * **Integration with external APIs:** Use Python libraries for any external services: e.g., `django-anymail` or `sendgrid` for emails, Twilio‚Äôs Python SDK for SMS/WhatsApp, Stripe‚Äôs Python SDK for payments. Encapsulate these in service classes or utility functions. For example, a `PaymentService` class to create charge or payment intent, a `NotificationService` to send messages. Keeping these abstracted makes it easy to swap providers or update logic without touching core views.

* **Admin Interface (Django Admin):**
  Django‚Äôs built-in admin will be a powerful tool for Teresa to manage the shop behind the scenes. We will customize it for usability:

  * **Order Admin:** Show relevant fields in list view (order number, delivery date, recipient name, status, total). Enable filtering and sorting by date and status, so Teresa can easily see ‚Äútoday‚Äôs deliveries‚Äù or ‚Äúpending orders‚Äù. We can add a **filter by date** (using Django‚Äôs list\_filter with a custom DateField filter or an integration like django-admin-rangefilter for date ranges).
  * Add an **action button or shortcut** in admin to mark orders as delivered or in preparation. For example, select orders and choose ‚ÄúMark as Out for Delivery‚Äù from an actions dropdown ‚Äì this will update the status for multiple orders and trigger notifications in bulk if needed (useful if starting the morning by marking all as ‚ÄúIn Preparation‚Äù).
  * **Calendar View:** While the Django admin doesn‚Äôt have a calendar by default, we can either install a plugin (there are admin calendar libraries) or create a simple custom admin view. One approach is to create a read-only page that displays a calendar (perhaps using FullCalendar JS or a simple table calendar) with orders on each date. This might involve writing a custom admin view (Django admin allows adding custom views to the admin site). Another approach is to use the Django admin **calendar widget** in the filter or rely on exporting data to Google Calendar. As a simpler solution, we might integrate Google Calendar by letting the system create events for each delivery on Teresa‚Äôs Google Calendar via API ‚Äì but that‚Äôs outside MVP. For now, likely a **custom dashboard page** that queries orders and displays a calendar-like overview would be ideal, if feasible within time.
  * **Product Admin:** Allow Teresa to add/edit products easily. We‚Äôll use Django admin‚Äôs image upload for product photos ‚Äì ensure `ImageField` is configured and media storage is set up. She can update descriptions, mark items active/inactive, and set prices or categories. If she isn‚Äôt highly technical, we‚Äôll simplify forms via help texts (e.g., help text under ‚ÄúSeasonal End Date‚Äù like ‚ÄúLeave blank if always available‚Äù). Possibly use the Django admin inlines to allow adding multiple images per product on the same form.
  * **CMS/Content Admin:** For managing site content like an ‚ÄúAbout‚Äù section, or a blog, we can use Django admin as well. For example, create a model `Article` or `Page` with fields like title, body (maybe a rich text editor via a package like django-ckeditor for WYSIWYG editing), and allow Teresa to post updates. Next.js can then fetch these via an API to display on the site. This avoids needing a separate CMS. If this is too much initially, we can simply hard-code content and update via code, but it‚Äôs better to allow non-developers to change text on the site (especially for something like the ‚ÄúAbout me‚Äù story or seasonal promo banners).
  * **Security for Admin:** Ensure only authorized staff (Teresa and any future team members) can access the admin. Enforce strong passwords. Possibly configure 2FA for admin login (Django has plugins for TOTP-based 2FA) to protect sensitive customer info. Also, consider limiting admin access by IP or other means if needed, since it contains PII (customer addresses, etc.).
  * **Admin Notifications:** Integrate a way to notify Teresa of new orders aside from email ‚Äì e.g., we can use Django admin‚Äôs alert framework to pop a message if a new order comes in during her session. If using Django Channels, perhaps have a live update panel. Simpler: a refresh of admin order list every minute or a visible counter. Since Teresa might not always watch a screen, we rely on SMS/email for immediate new-order alerts (see Messaging), but the admin should clearly show which orders are new or pending (maybe highlight those not yet viewed).

* **Real-time and Concurrency:**

  * Use **Django Channels (WebSockets)** for any features requiring push from server to client (like live chat or live order status). For example, implement a Channels consumer that can send order status updates to a specific websocket room keyed by order ID or user. The Next.js frontend can subscribe (perhaps via a lightweight socket.io client or using the built-in WebSocket API and a simple protocol). This avoids heavy polling. If Channels is too complex to deploy initially, an alternative is to use **Server-Sent Events (SSE)** via an HTTP endpoint for streaming updates, or a third-party like Pusher. But Django Channels keeps data on our server, aligning with privacy.
  * Ensure the backend can handle concurrent requests: Gunicorn with multiple workers will serve API calls concurrently. For any blocking tasks (image processing, sending emails, heavy AI calls), use asynchronous tasks. We can integrate **Celery** with a Redis or RabbitMQ broker to handle background jobs (e.g., sending out 50 SMS messages for Valentine‚Äôs day orders, or generating AI suggestions which might be slow). This prevents slowing down user-facing requests.
  * The **combination of Django + DRF** gives a solid, secure foundation. We benefit from Django‚Äôs ORM (for safe DB queries), form validation (we‚Äôll use DRF serializers for validating inputs like dates and messages), and a quick development cycle. All these backend choices aim to **streamline Teresa‚Äôs operations** ‚Äì by automating what can be automated (order handling, notifications) while giving her control (admin interface, personal touches in content).

## 3. Database (PostgreSQL)

Use **PostgreSQL** as the relational database. It offers reliability for transactions (important for orders/payments), and advanced features like JSON support (if we need to store structured data for AI logs or order metadata) and PostGIS for geospatial queries (if later needed for service radius or multi-city logic). The DB schema will be carefully designed to enforce business rules and enable future growth:

* **Schema Design & Relationships:**

  * The **Product table** will store bouquet information. Key fields: `name`, `description`, `price`, `is_active`, `slug`, etc., as discussed. We might have a separate **ProductImage** table for additional images, with a FK to Product (to allow multiple images per bouquet). If supporting variants (sizes), we have options: either include fields like `price_small`, `price_medium` in Product or have a `ProductVariant` table keyed to Product (with fields size name and price). The latter is more flexible if each variant can have its own stock count or image. Initially, since bouquets are made on demand, we might not need an inventory count per product (flowers are sourced daily). But if Teresa has some ready-made arrangements or limited stock items, we could add an `inventory` field or a simple available quantity that she can adjust.
  * The **Order table** ties to **User** and possibly to **Recipient/Address** (if separate). Each Order will have a relation to one or many products via OrderItem. If using an **OrderItem table**: it stores `order_id`, `product_id`, `quantity`, `unit_price`, and any variant info (like `size` selected). Order has a total price field for quick access; we can compute it from items + delivery fee and store it for record (helps in reporting, even if redundant). We also store `delivery_date` (as a date type) and maybe `delivery_slot` (could be a small string like "Morning" or a time field if exact). We‚Äôll index `delivery_date` since queries like ‚Äúhow many deliveries on X date‚Äù or ‚Äúfind next deliveries‚Äù will be common. An index on `status` might help to quickly fetch ‚Äúpending‚Äù or ‚Äúpreparing‚Äù orders for the admin dashboard.
  * **User table** is standard (if extending AbstractUser, we keep the usual username/email/password). We will use email as the unique identifier for login (Django can be configured for that). In an extended profile or via related model, store phone, loyalty points, etc. We should **normalize the address data**: we could either just keep address as free text fields on Order/Recipient (street, city, postal code, etc.), or have an Address table to reuse addresses (which ties into saved recipients). Simpler: have address fields on order for now. But design with possibility to factor out later if needed (perhaps implement `RecipientAddress` model and link order to it ‚Äì that avoids copying the same address strings for returning customers).
  * **Recipient table** (optional as noted): If implemented, has fields: `name`, `address_line1`, `address_line2`, `city`, `postal_code`, `phone`, and maybe a `user` FK to the sender who frequently uses this recipient. Could also have a unique hash to avoid duplicate entries of the same person. But this can be added later; initially, storing in Order might suffice.
  * **Loyalty tracking**: Could simply be fields on User (e.g., `orders_count`, `total_spent`, `loyalty_points`). Each completed order triggers an update to these. If points have an expiration or more complex logic, a separate `LoyaltyPoint` transaction log table might be used to record issuance/redemption (so, for example, Teresa can audit how points were earned). For now, assume a simple ‚Äú5 orders = next order 10% off‚Äù type of program, which can be calculated on the fly or stored as a flag (like `User.is_vip` after 5 orders). The database can easily perform aggregates for insights (e.g., count orders per user, sum total spending), which can feed marketing efforts (like identifying top customers).
  * **Scheduling Constraints:** We don‚Äôt enforce business rules (like max 5 deliveries per day) at the DB schema level (that‚Äôs logic in backend), but we might have a helper model for **DeliverySlots** if needed. For example, a `DeliverySlot` table keyed by date with a counter of how many orders booked. Each time an order is placed, increment the count for that date. If we reach the limit, mark that slot as full. Alternatively, simply query Order count for that date. For performance with many orders, a counter table or a materialized view could be used. Given initially volume is manageable, a query like `SELECT COUNT(*) FROM orders WHERE delivery_date = X` is fine. As volume grows, an index on `delivery_date` ensures this remains fast. If we allow specific time windows, we might extend this concept: e.g., `DeliveryWindow` model (date + window identifier + capacity). But if Teresa mostly does date-based scheduling and coordinates exact times personally, we may not need fine-grained slot tables yet.
  * **Spatial Data (PostGIS):** In case we need radius filtering (e.g., ensure delivery address is within 20km of shop), we can add a `Point` field for address coordinates. For now, addresses are strings ‚Äì but we can integrate a geocoding step when an order is placed (use Google Geocode API to get lat/long, store it). With PostGIS enabled, we could then do a quick distance query. Example: a function `is_within_service_area(lat,long)` that checks distance from home base. If we foresee multi-city, we might also tag which city or region for an order which helps assign to the right florist. This is more relevant in the **Extensibility** section, but laying the groundwork with a PostGIS extension means we won‚Äôt face migration pain later.

* **Delivery Date Logic in DB:**

  * We will ensure the **delivery\_date** field is a date type (no time zone issues, as deliveries are local and date-specific). For time slots, either a separate field or encode it in a single DateTime if an exact time is selected. If using a separate field like `delivery_slot`, it can be a choice or smallint referring to a time window code (1 = morning, 2 = afternoon, etc.).
  * **Preventing Overbooking:** While the DB can‚Äôt ‚Äúlock‚Äù a date capacity easily by itself, we can leverage transactions. The order placement flow can be wrapped in a transaction where we: 1) count existing orders for that date with `SELECT ... FOR UPDATE` to lock those rows or a row in a hypothetical `DeliverySlot` table, 2) if count < limit, insert the order. This way two parallel checkouts on the last available slot won‚Äôt both succeed. Django‚Äôs ORM with `select_for_update()` can be used if needed. For initial simplicity, the risk of collision is low, but it‚Äôs good to mention for robustness.
  * We‚Äôll also use constraints for data integrity: for example, ensure `delivery_date >= today` (no past dates) via validation in model or serializer. Possibly ensure `card_message` max length is enforced at DB level (can set a max\_length on TextField or use a CharField for smaller messages).

* **User & Recipient Data Separation:**

  * The database will clearly separate **sender (buyer)** data and **recipient** data. The User table holds the sender‚Äôs login info and possibly billing info, whereas each Order carries the recipient‚Äôs delivery info. This distinction is important for GDPR: the recipient‚Äôs personal data is not tied to a user account unless the user saved it, and it‚Äôs used only for order fulfillment. We‚Äôll document that in privacy policy and ensure it‚Äôs only retained as long as necessary.
  * If a user deletes their account, we must decide how to handle associated orders/recipients. Likely we‚Äôll anonymize personal identifiers on past orders (so historical sales stats remain but personal info is wiped). The schema should allow nulling or blanking those fields if needed.
  * If implementing saved recipients, the table linking user and recipient info will facilitate quick re-ordering (user can pick a recipient record instead of typing anew). The relationship is one-to-many (one user, many recipients). We‚Äôll enforce via code that users can only access their own recipient entries.

* **Supporting Loyalty Features:**

  * The DB is equipped to support loyalty and expansion. For instance, with an `orders_count` on User or a separate Loyalty table, we can easily query ‚Äúwho reached 5 orders‚Äù and apply rewards. If we use a separate `LoyaltyTransaction` model, we could support points that expire or complex campaigns (e.g., double points in holiday season). But initially, a simpler aggregate stored on User and updated via signals after order completion suffices.
  * Another feature: track referral or first-time customers. We might add a `referred_by` field if Teresa wants to do referral credits (‚ÄúFriend referred you? Enter code‚Äù). Not requested now, but schema is flexible to add such fields.
  * **Reviews/Testimonials:** If we allow customers to leave a review, a `Review` model (user, order, rating, comment, date) can be added, and we could display those on the site. The database can handle it easily and relate reviews to orders to ensure only actual purchasers can review. This ties into building trust on the platform.

* **Analytics & Querying:**

  * PostgreSQL will be used for analytical queries too. For example, we can craft queries or use Django ORM to find *sales by date*, *popular products*, *repeat customer rate*, etc. Using Django‚Äôs aggregation, or direct SQL for complex analysis, Teresa (or an analyst) can derive insights. If needed, connect a BI tool or simply export data to CSV through admin for offline analysis. The data model captures all key events (we may also log each status change in a small `OrderStatusHistory` table for audit trail ‚Äì e.g., a model with order, status, timestamp, user who changed it, to have a history of what happened. Good for internal record, albeit not strictly required).

Overall, the PostgreSQL schema under Django‚Äôs management ensures **data integrity and consistency**. We design it to mirror the real-world workflow (one order = one delivery = one happy recipient, with clear linkage to the sender and the bouquet details). This structured approach guarantees that as orders flow in during peak times (Mother‚Äôs Day rush, etc.), the data remains accurate and queries remain efficient ‚Äì enabling Teresa to trust the system as much as her own memory in the old paper-and-pen days.

## 4. AI Agent Integration (Flowise)

To preserve Teresa‚Äôs personal touch at scale, we integrate **AI agents orchestrated by Flowise** ‚Äì each agent handles a specific role to enhance customer experience and operations, always following Teresa‚Äôs warm, caring style. Flowise (an open-source platform for building AI workflows) will allow us to visually design and tweak these agents, and provides APIs to integrate them with our Django backend.

* **Floral Concierge Chatbot:**

  * *Purpose:* Act as a virtual shop assistant on the website, helping customers pick the perfect arrangement. It greets users in a friendly tone (‚ÄúHello! I‚Äôm your floral assistant ü§ñüå∑. Looking for something special today?‚Äù) and can handle questions like *‚ÄúWhat flowers should I get for my  anniversary?‚Äù*
  * *Implementation:* Using Flowise, we‚Äôll build a **Chatflow** with an LLM (e.g., GPT-4 or an open-source equivalent) that has been primed with knowledge of our products and floral expertise. We will feed it data such as: product catalog (names, occasions, descriptions), floral meanings (e.g., ‚Äúroses symbolize love‚Äù), and business rules (delivery area, available services). The agent can use **tools** for more precise help: for example, a custom *product search tool* that allows the AI to query our product API based on occasion or budget. Flowise supports tool calling, so we can configure an endpoint tool: when the user says something like ‚Äúbirthday gift under 100 PLN‚Äù, the agent triggers a tool that hits our `/api/products?occasion=birthday&max_price=100` endpoint, gets results, and then the AI weaves those into its answer (‚ÄúWe have a cheerful *Sunshine Bouquet* perfect for birthdays, priced at 80 PLN, featuring bright sunflowers that mean happiness!‚Äù).
  * *Integration:* On the frontend, the chatbot UI will send user messages to a backend endpoint (e.g., `POST /api/ai/concierge-chat/`). Django will forward the query to the Flowise API (which might be running as a separate service or container). Flowise will return the assistant‚Äôs reply along with any rich content (we can design the agent to return some structured data when recommending a product, like a product ID or URL). The backend then sends this to the frontend chat UI. We maintain conversation context by using a session ID or having Flowise handle state (Flowise can maintain state per chat session).
  * *Tone & Brand Voice:* We will craft the system prompt for this LLM agent carefully: it will speak as if it‚Äôs Teresa‚Äôs knowledgeable assistant ‚Äì **warm, polite, and personalized**. For instance, it might introduce itself as ‚ÄúTeresa‚Äôs virtual assistant‚Äù and use gentle, encouraging language (‚ÄúI‚Äôd love to help you make someone‚Äôs day with flowers!‚Äù). It will **never feel like a cold bot**; even though it‚Äôs AI, it should emulate the empathy and enthusiasm a human florist has. We‚Äôll test it with various questions to fine-tune responses.

* **Message Drafting Assistant:**

  * *Purpose:* Help customers write heartfelt card messages to accompany their flowers, addressing a common pain point (‚ÄúI‚Äôm not sure what to write‚Ä¶‚Äù). This AI will generate suggestions for what to write on the note.
  * *Implementation:* We‚Äôll implement this as a simple API call to an LLM (possibly via a Flowise flow as well). When the user is on the ‚ÄúAdd Message‚Äù step of checkout, they can click ‚ÄúNeed inspiration for your message?‚Äù. The frontend will call `POST /api/ai/message-suggest/` with context: possibly the occasion and recipient relationship (we can gather this indirectly: if the user selected ‚ÄúAnniversary‚Äù occasion or from the chat context or even explicitly ask ‚ÄúIs this for your wife, friend, etc.?‚Äù). The backend calls a Flowise *Chatflow* specialized in message generation. The prompt template for this agent could be something like: *‚ÄúThe user is sending flowers for {occasion} to their {relationship}. Suggest a short, heartfelt message in a warm, personal tone. If the user specified a preferred tone ({e.g., funny or very emotional}), incorporate that.‚Äù*. The LLM then returns one or a few suggestions (e.g., 2-3 variations).
  * *Integration:* The Django endpoint receives the suggestions and returns them to the frontend, which displays them perhaps in a list under the message box. The user can click a suggestion to edit or accept it. We‚Äôll ensure the suggestions are reasonably short (to fit on a card) and we might apply a character limit post-processing just in case. Possibly, filter out any inappropriate content (though our prompt should keep it wholesome, it‚Äôs good to be safe given user inputs).
  * *Brand Alignment:* The messages the AI generates should reflect the same emotional sincerity Teresa would use. We can train the model with a few examples of notes Teresa has written or would write. (For instance, show it examples of a thank-you note, a love note, etc., so it learns the style). This makes the AI an extension of Teresa‚Äôs expressive ability, thereby enriching the user experience in a very personal way.

* **Delivery Route Optimizer Agent:**

  * *Purpose:* Assist Teresa in planning efficient delivery routes for the day‚Äôs orders, saving time and ensuring timely deliveries (especially on busy days with many orders). This agent works behind the scenes for the admin/operations side.
  * *Implementation:* We can implement this as a Flowise **Agentflow** that can use external tools (like a maps API). For example, we give it access to a **Google Maps Distance Matrix API** tool or an OSRM service. When triggered (say, Teresa clicks ‚ÄúOptimize Route‚Äù for today in the admin dashboard), the backend will collect all addresses for orders of that day, feed them to the agent. The agent will then: 1) possibly geocode addresses to lat/long (if not already stored), 2) compute distances or travel times between all points (this could be heavy, so maybe limit to 5-10 deliveries typical for a day), 3) use an algorithm or the LLM‚Äôs reasoning to find a sensible route. We might not rely on the LLM alone for exact TSP (traveling salesman problem) ‚Äì a more deterministic approach is preferable. One plan: use Google‚Äôs API to get an optimized route (Google Maps has a Directions API that can optimize waypoints for you). Alternatively, use a Python library (like `ortools` from Google OR-Tools) to compute the shortest path given a distance matrix. The AI agent‚Äôs role might then be more about presenting the route nicely (e.g., ‚ÄúSuggested route: Order #12 (City Center) -> Order #15 (North District) -> Order #13 (suburbs). Total drive \~25km. Start at 10:00 to make all timings.‚Äù).
  * *Integration:* This could be implemented as a Django management command or function, but using Flowise allows for an interactive approach ‚Äì e.g., the agent could flag if a time window request is impossible (‚ÄúOrder #9 requested 9am, but Order #8 is far and requested 9:30am, consider reassigning times‚Äù). In the admin UI, Teresa could input any constraints (like ‚ÄúI want to be done by 5 PM‚Äù or ‚ÄúI can‚Äôt go to this area first because shop opens at 10‚Äù etc.), and the agent could adjust. Initially, we may implement a simpler version: when Teresa clicks optimize, the backend calls the agent which returns an ordered list of deliveries. We then display that list (maybe as a numbered list of addresses or an embedded Google Map with the route). Teresa can still adjust it manually if needed, but it gives a strong starting point.
  * *Note:* Because this is operational, we won‚Äôt expose it to users directly. It‚Äôs an admin-helper. Over time, it can learn from traffic patterns or Teresa‚Äôs preferences (maybe it notices Teresa likes to do farthest delivery last to head back home, etc.), but MVP will focus on basic distance minimization and meeting any specified delivery time windows.

* **Customer Service Bot:**

  * *Purpose:* Provide instant answers to common customer queries and after-hours inquiries in a friendly manner. This agent covers FAQs like ‚ÄúWhat are your delivery hours?‚Äù, ‚ÄúCan you deliver on Sunday?‚Äù, ‚ÄúWhere‚Äôs my order #1001?‚Äù etc., and hands off to a human when it reaches its limit.
  * *Implementation:* We‚Äôll create a Flowise chatbot that has two main capabilities: **FAQ knowledge** and **order lookup**.

    * **FAQ Knowledge Base:** We‚Äôll compile frequently asked questions and policies (from Teresa‚Äôs input) such as delivery areas, refund policy (e.g., if the recipient isn‚Äôt home), flower care tips, etc. We can feed these as a knowledge base (Flowise supports knowledge retrieval, possibly via document QA or embedding search). This could be as simple as a JSON or markdown of Q\&A pairs that the agent is primed on, or more advanced using a vector database for semantic search.
    * **Order Status Tool:** We will enable the agent to retrieve order info by connecting it to an API tool. For example, if the user says ‚ÄúWhere is my order #1234?‚Äù, the agent can recognize the pattern, then call our `/api/orders/1234/` endpoint (with a secure token or maybe ask the user to verify email) to get status. We must ensure security here ‚Äì possibly the bot should only provide general info unless the user is authenticated or provides matching info (we don‚Äôt want someone to randomly query any order). If the user is logged in, it‚Äôs easier (the bot can use their identity to fetch only their orders). If anonymous on WhatsApp, perhaps the bot asks for the email or phone used on the order for verification. This is an area where a human takeover might be better for sensitive info. But basic queries like ‚Äúif it‚Äôs out for delivery, yes or no‚Äù might be answerable if we ensure privacy (maybe just ‚ÄúYour order is on track for today!‚Äù without details).
  * *Channels:* This bot can be deployed on the website (perhaps the same chat widget as the concierge, just that it can handle queries beyond product selection) and on messaging platforms. For website chat, we might integrate the concierge and FAQ into one agent ‚Äì or have them as separate flows and use an orchestrator that decides which one answers (Flowise could have a multi-agent setup where one is product concierge, one is FAQ, and they either work in parallel or based on user input context). Using keywords or intent detection, the system could route the conversation. For example, if user says ‚ÄúHi, I have a question about my order,‚Äù the FAQ agent should take over. If user is browsing and says ‚ÄúWhat do you recommend for...‚Äù, the product concierge handles it. This coordination can be done via Flowise Agentflows or a custom dispatcher in our backend that decides which flow to query.
  * *WhatsApp Integration:* We plan to connect WhatsApp Business API via something like Twilio. Incoming WhatsApp messages can be forwarded as requests to our bot (perhaps to the same backend endpoint as the web chat). The bot‚Äôs reply is then sent back via WhatsApp. We‚Äôll use template messages for the first greeting if needed (WhatsApp requires templates for proactive messages, but responding to user-initiated chats is free-form). This way, if a customer sends a WhatsApp at 10pm, they get an immediate helpful response (‚ÄúOur delivery hours are ... You can place an order for the next available date ...‚Äù) and if it‚Äôs something the bot can‚Äôt handle (‚ÄúCan I change my order details?‚Äù), it will politely say Teresa will get back in the morning. We‚Äôll ensure Teresa can see these chat transcripts (maybe emailed to her or in an admin log) so she can follow up personally if needed ‚Äì maintaining that human touch.
  * *Brand Voice:* This service bot will also speak in a cordial, helpful tone. Even if it‚Äôs automated, phrasing like ‚ÄúI‚Äôm here to help üòä‚Äù and signing off with ‚Äú‚Äì Kwiaty Teresy‚Äù gives it a personal feel. We‚Äôll avoid overly formal language; it should read like how Teresa would answer the phone in her shop. For tricky questions or sensitive issues, the bot will err on the side of capturing the query and assuring the user of a follow-up (‚ÄúI‚Äôm sorry I can‚Äôt resolve that right now. Teresa will reach out to you shortly to assist further.‚Äù). This ensures the technology never feels cold or dismissive.

* **Flowise Integration Details:**

  * We will host a **Flowise service** (could be on the same server or a separate Node server) which runs the defined agents. Flowise provides a REST API and possibly WebSocket interface to interact with these flows. Each Chatflow/Agentflow we create will have a unique ID or endpoint. For example, if the concierge chatflow ID is `xyz123`, we can call `POST /api/v1/prediction/xyz123` with a JSON payload `{"question": "What do you recommend for ...", "history": [...]}` to get a response. We‚Äôll wrap these calls in our Django views as mentioned, so the frontend never calls Flowise directly (to keep our API keys and logic hidden and allow us to add business logic in between).
  * **LLM Providers & Costs:** We‚Äôll use a combination of accessible LLMs. For high-quality responses, OpenAI‚Äôs GPT-4 or GPT-3.5 could be used (Flowise can connect to OpenAI API easily). We will configure the agents with our API keys and monitor usage. For cost control, we might use GPT-3.5 for quick chats and only use GPT-4 for more complex tasks or when high creativity is needed (like message writing). Alternatively, we could experiment with open-source models (running a smaller model on our server via something like HuggingFace transformers integration in Flowise). This avoids sending sensitive data out to third parties, but the quality might be lower. A hybrid approach: use OpenAI but ensure we don‚Äôt send full addresses or phone numbers to it (the prompts will focus on the abstract question, not raw personal data).
  * **Chaining & Multi-agent:** Flowise allows multi-agent orchestrations. For example, in the concierge chat, if the user says ‚ÄúAlso, I‚Äôm bad with words for the card,‚Äù the agent can internally invoke the message assistant agent to generate a suggestion and include it in the chat reply. We will design such chains deliberately. Another chain: after a purchase, we could have an AI agent draft a follow-up ‚Äúthank you‚Äù email or message to the customer ‚Äì but this we might hold off until tested, as it directly interacts with customers.
  * **Testing & Tuning:** We will thoroughly test the AI agents with sample conversations and edge cases. Since they represent Teresa‚Äôs brand, we‚Äôll fine-tune prompts to avoid any off-brand replies. We‚Äôll also include guardrails: e.g., if asked for something inappropriate (unrelated or disallowed), the bot should politely decline or hand off. Flowise supports adding logical conditions, so we can catch certain keywords or use moderate content filters on outputs. The AI should **never give out personal data** or commit to something we can‚Äôt do (for instance, if someone asks ‚ÄúCan you deliver to another country?‚Äù, the bot should respond with the policy rather than hallucinate an answer).

In summary, AI integration via Flowise will **elevate the customer experience** by providing guidance and warmth at scale, and assist Teresa in operations ‚Äì all while carefully maintaining the **human-centric charm** of Kwiaty Teresy. The technology acts as an assistant, not a replacement, ensuring efficiency and availability 24/7 without making the service feel automated or impersonal.

## 5. Messaging & Notifications

Timely, thoughtful communication is key to the customer experience ‚Äì it reassures senders that their emotional gift is in good hands. We will implement a robust messaging system (email, SMS, WhatsApp) to keep both Teresa and her customers informed at each critical stage, aligning each message‚Äôs tone with Kwiaty Teresy‚Äôs warmth.

* **Order Confirmation (Email):**
  As soon as an order is placed, the system sends a confirmation email to the buyer. This email will:

  * **Summarize the order:** bouquet name/description, delivery date and address, recipient name, and the customer‚Äôs personal message (so they have a record of what they wrote).
  * **Include Teresa‚Äôs touch:** a brief thank-you note from Teresa, expressing gratitude for trusting her with this special delivery. (e.g., ‚ÄúThank you for your order! I‚Äôll personally craft your bouquet with care ‚Äì Teresa.‚Äù)
  * **Branding:** Use a nicely designed email template with the shop logo, floral motifs, and brand colors. We‚Äôll keep it simple and mobile-friendly (one-column layout). Possibly include a photo of the bouquet if available, or a generic pleasant image.
  * **Technical implementation:** Use Django‚Äôs email framework, configured with a reliable SMTP or email service (like SendGrid, Mailgun, or AWS SES). For ease, we might integrate **django-anymail** to abstract various email providers. The email is triggered in the order creation flow (after payment success). It will be sent asynchronously via Celery to avoid slowing the checkout response.

* **Delivery Status Updates:**
  Many senders appreciate knowing when the flowers are on the way and delivered, so we‚Äôll provide notifications at these key points:

  * **Out for Delivery:** When Teresa (or staff) clicks ‚ÄúOut for Delivery‚Äù in admin (or at a set time on delivery day), trigger a notification to the sender. We can offer this via **SMS or WhatsApp** (since it‚Äôs time-sensitive and people might see a text faster than email). The message might read: ‚Äúüå∏ Your order from Kwiaty Teresy is on its way to \[Recipient Name]! ‚Äì We‚Äôll let you know once it‚Äôs delivered. Thank you for choosing us.‚Äù This reassures the sender in real-time. If the sender opted for email only, we send an email with similar content instead.
  * **Delivered:** When an order is marked delivered, notify the sender that it was successfully handed over. For example: ‚Äú‚úÖ Delivered! Your flowers to \[Recipient] were delivered at \[time]. We hope it made their day! ‚Äì Teresa‚Äù. If Teresa took a photo of the bouquet or the delivery moment and wants to share, the email could include that image (with recipient permission if needed). We have to be mindful of privacy ‚Äì perhaps just a photo of the bouquet at the door or in Teresa‚Äôs hands, not the person unless allowed. In SMS/WhatsApp, we‚Äôd stick to text or maybe a photo link due to MMS/WhatsApp support for images.
  * **Exceptions:** If an attempt failed (e.g., nobody home), Teresa can update order status to a problem state, which can trigger an alert to the sender like ‚ÄúWe attempted delivery but couldn‚Äôt reach the recipient. We‚Äôll coordinate a solution ‚Äì please check your email.‚Äù, and then follow up with details via email or a phone call. These are edge cases, but we should plan templates for them to handle gracefully.

* **Admin Alerts (New Orders):**
  Teresa should get immediate notice of new orders so she can start prepping. We‚Äôll set up an email notification to the business email or even an SMS to Teresa‚Äôs phone whenever a new order arrives: e.g., ‚ÄúNew order #1234 for June 5th delivery. Check admin for details.‚Äù This is easily done via Django signals on Order creation. We‚Äôll throttle it if needed (e.g., if a surge of orders come, maybe don‚Äôt text 50 times at once, but in normal days it‚Äôs fine). Additionally, if Teresa uses WhatsApp, we might integrate a WhatsApp message to her as well (using the same Twilio API with a different template, or a simpler route: send an email-to-SMS through her mobile carrier). Since she might often be on the go (buying flowers, delivering), an SMS alert ensures she doesn‚Äôt miss last-minute same-day orders.

* **Newsletter or Marketing Emails:**
  Down the line, Teresa might want to send newsletters (new collection announcements, holiday promotions). We‚Äôll ensure we **capture email opt-in** appropriately: at account signup or checkout, ask users if they want to receive updates. Those who opt in can be stored with a flag in the User model. We can later integrate with an email marketing tool or use our own mail system to send beautiful newsletters. For now, this is just noted for future ‚Äì no bulk emails will be sent without explicit consent, respecting GDPR.

* **WhatsApp Integration:**
  Use the **WhatsApp Business API** (via Twilio or Facebook‚Äôs Cloud API) for sending transactional messages. WhatsApp is great because it can handle rich text and is a common communication channel. We‚Äôll need to get message templates approved for things like order confirmation or delivery updates. For example, a template might be:
  ‚Äú*Hi {name}, thank you for your order #{order\_id} at Kwiaty Teresy. We‚Äôre preparing your bouquet for delivery on {date}. üíê Feel free to reply if you have questions.*‚Äù (Transactional templates must not be promotional per WhatsApp policy, so we‚Äôll keep them strictly informative and user-initiated after the first template).
  We will register templates like ‚ÄúOrderConfirmed‚Äù, ‚ÄúOutForDelivery‚Äù, ‚ÄúDeliveredConfirmation‚Äù in the WhatsApp Business console. Twilio‚Äôs API can then trigger these by filling in the placeholders. If the customer replies on WhatsApp, we can either let Teresa handle it manually via the WhatsApp Business app or pipe it to the customer service bot if it‚Äôs a common question ‚Äì depending on Teresa‚Äôs preference. Possibly a hybrid: simple queries auto-answered, anything complex flagged for Teresa.

* **SMS (Text Messages):**
  Not everyone uses WhatsApp, so SMS is a fallback for instant notifications. Using Twilio (or a local SMS gateway in Poland if needed for cost/local sender ID), we‚Äôll send short texts for ‚Äúout for delivery‚Äù and ‚Äúdelivered‚Äù. Example SMS: ‚ÄúKwiaty Teresy: Your bouquet for \[Recipient] is now delivered. Thank you! (Order #1234)‚Äù. Keep SMS concise (160 chars) and clear. We should also include an opt-out notice for any SMS that might be considered marketing, but these transactional ones typically don‚Äôt require it under most regulations. Still, to be safe: only send SMS to customers who provided a phone and expect updates. We‚Äôll add a checkbox ‚ÄúNotify me by SMS about delivery status‚Äù in checkout (pre-ticked if they entered a phone perhaps, but with clear consent language).

* **Email for Feedback & Follow-up:**
  After a delivery, especially if it was a gift, the sender might appreciate follow-up. We can schedule a friendly follow-up email to the sender a day or two after delivery: ‚ÄúHope the flowers were enjoyed! We‚Äôd love to hear how it went. If you have a moment, please let us know or leave a review/testimonial.‚Äù Possibly include a simple star rating link or just a thank you note encouraging them to order again. This drives engagement and gives Teresa feedback. Implement via a scheduled Celery task that checks delivered orders from 2 days ago and sends emails. (Make sure to not send if the user opted out of any further emails).

* **Technical Notes:**

  * We will use **Celery** (background jobs) for sending notifications to avoid delaying the web requests. For instance, order confirmation email can be queued to Celery after the Order object is saved. Same for SMS dispatch on status change ‚Äì the admin action triggers a task. This ensures the website stays snappy for users.
  * All notification content will be stored as templates, possibly in the database or as Django template files. Storing them in a table (editable via admin) could let Teresa tweak the wording (keeping her voice consistent). If not, we‚Äôll hardcode them initially with placeholders. We‚Äôll have to be careful with translations if needed ‚Äì but presumably all in one language (Polish or bilingual if Teresa serves both locals and expats; we might consider bilingual templates if needed).
  * **Logging & Error handling:** We‚Äôll log all outbound communications (e.g., in an `EmailLog` or `MessageLog` model) with fields: order, type (email/sms), status (sent, failed), timestamp. This way, if a customer says ‚ÄúI didn‚Äôt get any email‚Äù, Teresa can check logs in admin to troubleshoot. Also, any failure (like SMS gateway down) will raise an alert (we could email an admin if a critical notification fails so Teresa can manually inform the customer).

By implementing these messaging features, customers stay **informed and reassured** every step: from purchase to delivery. The tone of all communications will remain personal and caring ‚Äì essentially scaling Teresa‚Äôs habit of friendly updates to a broader audience via technology. This builds trust and excitement, as customers feel connected to the process of their special delivery.

## 6. Deployment Strategy

We will deploy the system in a way that ensures **reliability, security, and ease of updates**, using a setup that separates concerns but remains manageable for a small business setup. The deployment will involve two main parts (frontend and backend) and supporting infrastructure components (database, proxy, etc.), likely on cloud VPS instances or platforms.

* **Infrastructure Overview:**

  * Host the **Django backend** on a VPS (Virtual Private Server) or cloud instance (e.g., DigitalOcean, AWS EC2, etc.) where we have full control. This instance will run the Django app (via Gunicorn) and possibly Celery workers for background tasks.
  * Host the **PostgreSQL database** on a managed service for reliability (e.g., DigitalOcean Managed DB, AWS RDS) or on the same VPS if usage is low and we prefer simplicity. A managed DB is safer for backup, updates, and scaling.
  * Deploy the **Next.js frontend** either on a Node server or a specialized service:

    * Option A: **Vercel** ‚Äì Next.js is first-class on Vercel, which can handle SSR and auto-scaling easily. We‚Äôd connect the Git repo to Vercel for CI/CD, and set environment variables (like API URL) there. Vercel would give us a global CDN for static assets, and serverless functions for SSR. This is convenient and fast.
    * Option B: Self-host Node ‚Äì run `next start` on our own server (could be the same as Django‚Äôs or another) behind Nginx. This gives more control over caching and integration, but requires more maintenance.
  * **Nginx Reverse Proxy:** Use Nginx as a front-facing server (possibly on the backend VPS or a separate small VM if using Vercel for front). Nginx will handle SSL termination (HTTPS) and route traffic: for example, `https://kwiatyteresy.com/api/` and `/admin/` to the Django backend, and everything else (the root and front-end pages) to the Next.js app. If Next.js is on Vercel, we might not need Nginx for it ‚Äì we‚Äôd point the main domain to Vercel and perhaps host the API on a subdomain like api.kwiatyteresy.com. But having Nginx unify them on one domain could avoid cross-site issues. A likely setup:

    * `www.kwiatyteresy.com` ‚Äì Next.js (either via Nginx proxy to Vercel or served by Node)
    * `api.kwiatyteresy.com` ‚Äì Django (with Nginx proxy to Gunicorn)
      Or we can serve API under `/api` path on the same domain. If using Vercel, that‚Äôs tricky (since Vercel can‚Äôt proxy to our API), so subdomain might be simpler. In either case, configure CORS on Django to allow the front domain.
  * **Static & Media files:** We need to serve images (bouquet photos, etc.) and static assets (admin CSS/JS, etc. for Django). With Nginx in place, we can point it to serve Django‚Äôs static files directory and media upload directory. We‚Äôll configure Django‚Äôs `STATIC_ROOT` and `MEDIA_ROOT` and after each deploy, collectstatic to gather static files. Media (uploaded images) might be stored on the server‚Äôs filesystem and served via Nginx, or on cloud storage (AWS S3 or similar) if we want to offload. Initially, to keep it simple, storing on disk is fine, but we will arrange backups for the media folder. If using multiple servers or scaling, we‚Äôd switch to S3.
  * **SSL Certificates:** Use Let‚Äôs Encrypt to obtain certificates for the domain (and subdomain). We can automate renewal with Certbot. All traffic will be HTTPS to protect sensitive info (logins, payments). Nginx will enforce redirect from HTTP to HTTPS.

* **Environment Separation:**

  * Maintain at least two environments: **Development** (for internal testing) and **Production** (live). Possibly a **Staging** environment if needed, which mirrors production for final QA (this could be simply using a staging subdomain on the same server or a smaller separate server).
  * Use environment variables for all secrets and env-specific settings: e.g., Django `DEBUG` flag false in prod, secret keys, API keys for Stripe/Twilio, database credentials, allowed hostnames, etc. In dev, DEBUG true and maybe use a local SQLite or a separate Postgres schema. We ensure not to commit secrets to code (they‚Äôll be injected via the server or Vercel config).
  * For Django, have separate settings files or use django-environ to load vars. In production, turn on security settings (SECURE\_COOKIE, CSRF\_COOKIE\_SECURE, ALLOWED\_HOSTS set properly, etc.).
  * On the Next.js side, use a `.env` file (not checked in) for API base URL and any keys needed (though mostly keys are in backend). Vercel has separate environment configs for preview and production, which we‚Äôll utilize if we go that route.

* **Process Management:**

  * **Gunicorn & Workers:** Run Gunicorn with a few worker processes (the number tuned to server CPU cores, e.g., 3-4 workers) to handle Django requests. Use the `--preload` and other Gunicorn settings for efficiency. We may also use **Uvicorn**/ASGI if we deploy Django with ASGI (for websocket support via Channels). In that case, we might choose Daphne or Uvicorn workers for the ASGI app. Nginx doesn‚Äôt care whether it‚Äôs WSGI or ASGI, it just proxies. If Channels (websockets) are used, we‚Äôll run a Daphne process for websockets and route those connections separately (maybe on another port or path). Alternatively, use an intermediary like Redis + Celery for background and have the front poll, if websockets prove too complex.
  * **Celery Workers:** Deploy a Celery worker (or multiple) on the backend server or another worker server. This will run tasks for sending emails, processing any heavy jobs (like calling AI APIs if we don‚Äôt want those on the main thread). Use a Redis instance as the message broker (Redis can be on the same server or a managed service; it can double as a cache if needed for Django). Ensure to secure the Redis (require auth and local access only).
  * **Flowise AI Service:** The AI agents could be run as a separate service (Flowise provides a way to start a local server). We might deploy Flowise on a Node environment (maybe on the same server as Next.js if capacity allows, or even within a Docker container on the backend host). Since Flowise might need more memory (for LLM context) and possibly GPU if using local models, we will plan accordingly. Initially, using OpenAI API offloads the heavy compute to OpenAI‚Äôs servers, so the Flowise service mainly orchestrates. We‚Äôll run Flowise behind the scenes and secure it (e.g., firewall it so only our backend can call it, not expose it publicly).

* **Continuous Integration/Deployment (CI/CD):**

  * Use a Git repository (e.g., GitHub or GitLab) for version control. All development goes through pull requests, which trigger CI pipelines.
  * **Testing:** Set up automated tests for critical pieces (Django unit tests for model logic, a few API endpoint tests, and perhaps Cypress or Playwright tests for basic frontend flows). The CI pipeline will run these tests on pushes.
  * **Deployment Pipeline:**

    * For Next.js: if using Vercel, integration is straightforward ‚Äì every push to main can trigger a production deploy (after tests pass), and pull requests can have preview deploys for review. If self-hosting Next, we can use GitHub Actions to SSH into the server, pull the latest code, run `npm install && npm run build` and restart the Node process. Or build a Docker image for Next and run that container.
    * For Django: set up a similar pipeline. Perhaps build a Docker image (with Gunicorn and our code, based off Python 3.x slim). Push the image to a registry. Then either automatically or manually deploy that image to the server (if using a container runtime) or use Fabric/Ansible scripts to pull code and install on the VM. If not using containers, a simple approach: SSH in, git pull, install deps (`pip install`), run migrations, collectstatic, then restart Gunicorn. This can be automated with a GitHub Action or a deploy script triggered by CI.
    * We will use **migrations** for DB changes (Django‚Äôs migrations will handle schema changes). The deploy process will always run `python manage.py migrate` to apply any new migrations, ensuring zero downtime migrations if possible (Django is pretty good if done carefully; for big changes we‚Äôd plan maintenance windows).
  * **Zero Downtime:** Aim for zero (or minimal) downtime deploys. With Nginx and Gunicorn, we can use Gunicorn‚Äôs graceful restart (send HUP signal) to reload code without dropping connections. For Next.js, if on Vercel, it‚Äôs seamless. If self-hosted, we can start the new build on a different port and then switch Nginx once ready (blue-green deployment manually). Given the scale, a few seconds downtime at off-peak might be acceptable, but we‚Äôll try to minimize it.

* **Scaling & Monitoring:**

  * Start with a modest sized server (e.g., 2 CPU, 4GB RAM) which should handle initial traffic. Monitor usage, especially around peak times like Valentine‚Äôs Day. If we notice high load (CPU spiking due to many simultaneous SSR or heavy traffic), we can scale:

    * For frontend, if not on Vercel, we can add more Node instances behind Nginx or move to a managed platform.
    * For backend, we can scale vertically (bigger machine) or horizontally (multiple Gunicorn instances and a load balancer, or using Kubernetes if we go that route eventually). Given the startup context, vertical scaling and caching will likely suffice initially.
  * **CDN:** We can use a CDN (Content Delivery Network) for static assets and images if global reach is needed, but since it‚Äôs a local business in Silesia, local hosting + Cloudflare CDN (just by pointing domain through Cloudflare with caching) could speed up static asset delivery to local users.
  * **Monitoring:** Implement basic uptime monitoring (Pingdom or UptimeRobot to alert if site goes down). Use application performance monitoring like **Sentry** for error tracking on both frontend (capture any JS errors) and backend (Django exceptions). Also set up logging on the server (Nginx access logs, Gunicorn logs) ‚Äì we might aggregate these with a service or at least have logrotate. Keep an eye on key metrics: response times, error rates, and database performance (maybe enable Django debug toolbar on staging to find slow queries and add indexes accordingly).
  * **Backups:** Schedule automated backups for the PostgreSQL database (if managed, the provider often has this; if self-hosted, use cron + `pg_dump` daily, and securely copy to a storage). Also back up media uploads periodically. We can‚Äôt afford to lose order history or customer data, so offsite backups (e.g., to an S3 bucket or another server) are important.

Overall, the deployment strategy emphasizes a **robust production environment** ‚Äì secure, scalable, and maintainable ‚Äì without over-complicating (we won‚Äôt immediately jump to Kubernetes or microservices, to keep ops manageable). By using services like Vercel and managed databases where possible, we offload a lot of heavy lifting, allowing Teresa‚Äôs platform to run reliably so she can focus on flowers, not servers.

## 7. Security & Compliance

Trust and safety are paramount, especially when handling personal messages and delivery addresses. We will enforce strong security measures and adhere to privacy laws (like **GDPR**) to protect both customers and the business. Here‚Äôs how we‚Äôll address security and compliance on all levels:

* **Data Protection (GDPR Compliance):**

  * **Privacy Policy & Consent:** We will draft clear Privacy Policy and Terms of Service pages outlining what data we collect (sender info, recipient info, order details), how it‚Äôs used (fulfilling orders, updates, loyalty), and how it‚Äôs not used (we won‚Äôt sell it, etc.). On the checkout form, we‚Äôll include a checkbox or notice for the sender to confirm they have the recipient‚Äôs consent to use their data for delivery (GDPR‚Äôs ‚Äúpermission to use someone‚Äôs personal data‚Äù since the recipient isn‚Äôt directly providing it). This is a tricky area: under GDPR, processing recipient data is lawful under ‚Äúlegitimate interest‚Äù (delivering a gift they presumably expect or at least the sender has a relationship), but we‚Äôll still handle it sensitively ‚Äì use it only for delivery and necessary communications around that.
  * **Data Minimization:** Only collect data we need. For example, we ask for recipient‚Äôs phone solely for delivery coordination, not for marketing. We won‚Äôt ask for unnecessary info like recipient email (unless we add an e-card feature, but not now). We‚Äôll store only what‚Äôs needed to complete the delivery and send status updates. If we integrate WhatsApp for customers, we‚Äôll ensure an opt-in (like ‚ÄúCheck here to receive WhatsApp updates about your order‚Äù).
  * **Right to Erasure:** Implement a process to delete user data upon request. If a customer asks to delete their account, we will remove or anonymize their personal data in orders (we can keep order records but remove identifiable info). Same for recipients ‚Äì though typically a recipient might not know we stored their data, if the sender or recipient ever requests deletion, we comply. We‚Äôll make it possible via customer service or eventually a self-serve ‚ÄúDelete account‚Äù button (with verification, since deletion is irreversible).
  * **Data Retention:** Determine a reasonable retention period for personal data. For instance, we might keep order details for X years for accounting, but perhaps anonymize recipient addresses after 6 months since they‚Äôre not needed long-term. We will consult any local legal requirements for retaining transaction data (financial records often need 5+ years retention by law, but we can anonymize personal parts).
  * **Export/Access:** If a user requests a copy of their data (GDPR right to access), we should be able to provide, for example, a summary of their orders and info. This can be done manually at first (query the DB and export), but it‚Äôs something to be aware of.

* **Web Application Security:**

  * **Authentication & Sessions:** We‚Äôll use established libraries (DRF auth, JWT) and follow best practices. Passwords are stored hashed (Django uses PBKDF2 by default, which is secure). For JWT, we‚Äôll use secure signing keys and short-lived access tokens with refresh tokens if needed. If using cookie-based sessions, set them HttpOnly and Secure (so they can‚Äôt be accessed by JS or sent over HTTP). Implement throttle on login attempts to prevent brute force (DRF has throttling classes or use Django Axes library).
  * **Authorization:** Ensure that API endpoints enforce permissions properly. For example, a user can only GET `/orders/{id}/` if that order belongs to them (or they present the secret tracking token). Admin-only endpoints are protected either by admin login or special tokens. We‚Äôll test that there‚Äôs no data leakage (like an order list API should not return others‚Äô orders).
  * **Input Validation:** Use DRF serializer validation and Django model validation to check data sizes and formats. This prevents issues like overly long messages causing issues, or invalid addresses. It also guards against some injection attacks ‚Äì e.g., if we ever use raw SQL (we mostly won‚Äôt, Django ORM covers that), always parameterize inputs.
  * **XSS & CSRF:** The Next.js frontend and DRF API split means we won‚Äôt rely on Django‚Äôs template engine much (except maybe admin). Still, ensure any data we inject into pages (like through Next SSR) is sanitized. React by default escapes content, so we‚Äôre safe unless using `dangerouslySetInnerHTML` (which we won‚Äôt except perhaps for CMS content, in which case we‚Äôll sanitize or only allow certain HTML tags). We‚Äôll enable Django‚Äôs **CSRF protection** for any session-auth endpoints and ensure the React app includes the CSRF token if using cookies. If using pure JWT, CSRF is not directly needed, but then we must secure against XSS stealing tokens ‚Äì which means keep JWT in HttpOnly cookie ideally, or in memory (in which case XSS could still grab it from memory). We‚Äôll lean towards HttpOnly cookie for JWT to get browser protections. Additionally, set Content Security Policy (CSP) headers via Nginx to restrict allowed script sources, reducing XSS risk.
  * **Encryption:** All data in transit is encrypted via HTTPS. For data at rest, the database can be encrypted at the filesystem level if using managed services. We ensure any backups we make are encrypted. Password reset tokens or any sensitive links we email will be one-time and time-limited. We won‚Äôt expose secrets in URLs (use IDs or UUIDs that don‚Äôt reveal info).
  * **Payment Security:** Since we use Stripe/PayPal, we do not handle raw credit card info. The frontend will use Stripe Elements or PayPal SDK to collect card details and get a token or payment intent, which is then sent to backend for confirmation. This way, the card data goes directly to Stripe, ensuring PCI compliance scope is minimal for us. We will still serve the pages over HTTPS and follow Stripe‚Äôs best practices for web payments.
  * **Admin Security:** As mentioned, enforce strong credentials for Teresa‚Äôs admin account. Possibly restrict admin login URL to a secret path (security through obscurity) or add 2FA. Since admin can change orders and view customer data, it‚Äôs a sensitive area. We might also log admin activities for audit (at least in logs, e.g., ‚ÄúUser Teresa marked Order#12 delivered‚Äù).
  * **Dependencies & Updates:** Keep all software up-to-date with security patches (Next.js, Django, etc.). We‚Äôll subscribe to security alerts (GitHub Dependabot) and schedule periodic upgrades. Because this is handling transactions, we might also consider a third-party security audit down the line or use scanning tools (like OWASP Zap or Snyk) to catch common vulnerabilities.

* **AI Agent Boundaries:**

  * The AI agents will be designed to not divulge sensitive data. We will **never feed private user data into the prompt** beyond what‚Äôs needed. For example, the concierge bot might know product info and maybe user‚Äôs first name if we want personalization, but it won‚Äôt have, say, their address or phone (no reason to). The order lookup tool for the service bot will only retrieve status, and the bot will confirm minimal info (‚ÄúFor privacy, I see the order is delivered, but I can‚Äôt share more details here‚Äù or it will ask them to verify identity).
  * We also have to ensure the AI doesn‚Äôt say anything off-brand or inappropriate. This is more a brand risk than security, but it‚Äôs important. We‚Äôll put content filters in place (OpenAI has some; we can also pre-check outputs for banned words or PII leakage). For example, if a user somehow asks the chatbot for another customer‚Äôs info, the bot obviously shouldn‚Äôt ever give it (and it won‚Äôt have that data anyway if we design it right).
  * Logs from AI conversations might be stored for improvement ‚Äì we will mention this in privacy policy if we do. We can anonymize those logs (e.g., strip out names) and certainly not use them beyond improving our service. If a user asks the AI something personal, that content might be transiently on our servers or OpenAI‚Äôs ‚Äì we‚Äôll disclose that and ensure we have proper data processing agreements with any AI provider. Possibly allow users to opt out of AI usage (though that might simply mean they don‚Äôt use the features).

* **Compliance (E-commerce Regulations):**

  * Ensure we comply with any local e-commerce laws: e.g., providing a clear refund/cancellation policy (flowers are perishable, often sales are final except issues ‚Äì we‚Äôll state that clearly to avoid disputes), listing business contact info on the site (physical address of the shop, org registration if any), and tax compliance (showing VAT in prices if applicable, providing receipts). Django can generate order invoices if needed, or at least we keep records to manually provide if someone asks.
  * If we expand to storing cookies for analytics or ads, we‚Äôll implement a **cookie consent banner** (especially in EU). For now, functional cookies (session, JWT) likely don‚Äôt require consent beyond the privacy policy, but Google Analytics or similar would. We may integrate Google Analytics to track site usage ‚Äì if so, we‚Äôll use the IP anonymization feature and update our cookie notice accordingly.
  * For WhatsApp/SMS, ensure we respect user preferences (only send transactional messages they expect). We won‚Äôt do telemarketing calls or spam ‚Äì fits the brand‚Äôs respectful approach.

In essence, by building security and privacy considerations from the ground up, we not only **protect users and the business legally**, but we also reinforce the brand‚Äôs trustworthiness. Customers can feel safe ordering through Kwiaty Teresy, knowing their personal messages and data are guarded with the same care that Teresa puts into her floral creations.

## 8. Extensibility

While the initial platform is tailored to Teresa‚Äôs current needs, we will architect it with future growth in mind. This ensures that as Kwiaty Teresy expands ‚Äì be it higher order volumes, new locations, or new sales channels ‚Äì the system can evolve without painful rework. Below are ways we‚Äôll future-proof the design:

* **Multi-City / Multi-Artisan Support:**

  * Right now, Teresa is the sole florist handling a certain region (e.g., Katowice area). If in the future she partners with florists in other cities (creating a network of artisans under the ‚ÄúKwiaty Teresy‚Äù brand or even franchise model), our system can accommodate that. We would introduce a **Florist (Artisan) model** to represent each partner florist or fulfillment center. Key fields: name, location (city or coordinates for service area), contact info, and perhaps their own delivery capacity per day. Orders would then be associated with a Florist.
  * **Assignment Logic:** We could automate assigning orders to the correct florist based on delivery address. For example, maintain a mapping of postal codes or use a radius check (with PostGIS) to find which florist is nearest or serves that area. The order placement backend logic can choose the florist and set it on the order record. This way, each florist in the network only sees their orders (we can filter in the admin or provide separate logins).
  * **Permissions & Admin:** Expand the admin system to allow each florist to have an account to manage their own products and orders. We can use Django‚Äôs built-in auth groups/permissions or a multi-tenant approach. Simpler: give each florist staff status but limit their view via custom admin filters (or use a separate admin site per florist subdomain). Alternatively, build a custom dashboard for florists outside of the Django admin that queries via API only their data. This ensures one florist can‚Äôt peek at another‚Äôs orders (important if they are independent).
  * **Catalog Sharing or Independence:** Decide if all florists offer the same product catalog or if each can have their own specialties. Our product model could have a ManyToMany to Florist or an availability map ‚Äì e.g., product X is available from florist A and C, but not B. Initially, Teresa might want consistency (her brand bouquets offered everywhere), but practically different florists might have different flower sources. We can handle this by either duplicating products per florist in the DB or linking them. We‚Äôll design the schema such that adding a foreign key from Product to Florist (meaning this product is created by that florist) or a join table is possible. For now, single Teresa means one florist, but we won‚Äôt hard-code things like ‚Äúthere‚Äôs only one calendar‚Äù.
  * **Scalability:** If multi-city becomes reality, we may need to scale infrastructure too (maybe separate instances per region or a beefier centralized server). Because we‚Äôre using a REST API and standard frameworks, scaling horizontally is straightforward: we can load balance by city or just by traffic. The database might need partitioning by region if it grows huge, but that‚Äôs far out ‚Äì PostgreSQL can handle a lot on a single instance.
  * The platform name ‚ÄúKwiaty Teresy‚Äù is singular, but if others join, we can still market it as a collective of artisans. We‚Äôll reflect that by possibly adding profiles on the site: e.g., ‚ÄúMeet Our Florists‚Äù page, where each florist (Teresa in Katowice, Anna in Krak√≥w, etc.) has a bio. The system will support that content easily with the new Florist model. The brand stays personal by highlighting each florist‚Äôs story (like Teresa‚Äôs vision extends through others).

* **Physical Store Integration:**

  * If Teresa has a physical boutique or opens one, we can integrate the inventory and ordering with the online system. For example, implement a **‚ÄúBuy Online, Pick up In-Store‚Äù** option: at checkout, allow user to choose delivery or pickup. If pickup, no address needed, and perhaps no delivery fee. The order would still go into the system but marked as pickup, and the confirmation would instruct the user with the shop address and hours. This requires adding a field `is_pickup` and maybe offering timeslots for pickup. Very doable with current schema.
  * In-store sales: We could use the system as a lightweight POS. For instance, Teresa could enter walk-in orders into the system via admin or a special quick interface. That way all sales are recorded in one place. We might create an ‚ÄúOrder Source‚Äù field (online, in-store) to differentiate. This helps track total business and manage loyalty (if a walk-in gives their email or phone, we can tie it to their account for points). If needed, integrate with receipt printers or credit card terminals might be considered ‚Äì but that might be overkill; even just logging it and emailing a receipt via our system could work.
  * **Inventory Management:** If the store sells items like vases or handmade gifts that are also on the website, we‚Äôd ensure the inventory deducts from one source. We can add a field `stock_quantity` to such products and decrement it on any sale (online or POS). For flowers themselves, because they‚Äôre made to order, we might not track each stem, but for ancillary products or limited edition arrangements, this matters. We can easily turn on Django‚Äôs built-in transactions to avoid race conditions on stock decrement.
  * **Unified Customer Data:** Some customers might interact both online and offline. With an account system, we could encourage in-store customers to sign up (maybe via email or phone number) so their purchases accumulate in one profile. The loyalty program can thus reward them regardless of channel. We‚Äôll make sure the data model can handle that (which it can, as long as orders can be linked to users and flagged with source).

* **Mobile App & Multi-Channel Integration:**

  * Because we chose a headless backend with REST API, creating a mobile app is straightforward. We can develop a **React Native** or Flutter app that talks to the same endpoints for products, orders, etc. The authentication can reuse JWT tokens or we implement OAuth for a smoother mobile login (e.g., login via Google/FB if we ever add social login). The mobile app could offer push notifications for order status (even more immediate than SMS). We could target this app either for customers or for Teresa/staff.
  * A **staff mobile app** could be handy: for example, when out on deliveries, Teresa can open a simple app that lists today‚Äôs deliveries, navigate via tapping an address to open Google Maps, and mark an order as delivered with one button (which triggers the customer notification). This would require building a lightweight authenticated app and giving staff accounts the right permissions. Since the backend and database already handle updates and status changes, it‚Äôs mostly an additional UI on top of existing logic. This is a natural extension once operations grow (especially if multiple drivers/couriers join).
  * **Integration with Other Platforms:** We can expose parts of the API or use webhooks to integrate with external services. For example, if Teresa wants to sell through Facebook or Instagram shops, we can either manually add those orders or build a small integration (like a webhook that creates an Order in our system when a Facebook order comes in). Similarly, connecting with Google Maps for live tracking could be possible (send a live link to the recipient or sender). Because we are API-driven, these integrations (though not trivial) won‚Äôt require a core rewrite, just extensions or middleware.
  * **Scaling Up Order Volume:** As the business grows (holidays, corporate contracts, etc.), we may incorporate features like **queueing orders** during peak (placing them is fine, but maybe scheduling deliveries over several days), or dynamic cutoff times (if too many orders, auto-disable same-day option). These can be config settings in the DB or environment (Teresa can adjust ‚Äúmax deliveries per day‚Äù in admin, for instance). The system‚Äôs design with clear separation of layers means adjusting such parameters mostly affects the backend logic and is easy to change.

* **Continuous Improvement and Modularity:**

  * We keep the code modular so new features plug in cleanly. For example, adding a new notification channel in future (maybe a mobile push notification service) would just require adding a new module in the notification service and possibly a device tokens table. The rest of the order workflow remains untouched.
  * The use of Django REST Framework means if we decide to implement GraphQL for more flexible front-end queries or integrate a third-party front-end (like maybe a partner site wants to embed a ‚Äúsend flowers‚Äù widget), we can do so by exposing a GraphQL API or specific endpoints without refactoring the whole system.
  * If AI usage grows (say we add more AI features like personalized product recommendations or an AI-driven marketing analysis), Flowise allows adding those flows. We might spin those off to separate microservices if needed for performance (e.g., a dedicated microservice for heavy AI tasks with its own scaling), but our architecture already isolates AI calls in a way (via clearly defined APIs), so separation is simple.
  * **Monitoring & Maintenance:** Extensibility also means maintainability. We will have logging and monitoring from the start, so if something is a bottleneck, we notice and can improve it. For instance, if the daily route optimization becomes too slow with many addresses, we might replace it with a more algorithmic solution rather than LLM. Since we encapsulated it behind an interface, swapping the implementation is feasible without changing the front-end or data models.

In conclusion, the platform is built not just for today, but for tomorrow‚Äôs possibilities. We ensure that **scaling up (more orders, more users)** or **scaling out (new services, locations)** is a smooth path. All new features will be evaluated against keeping the **artisanal, human-centric ethos**: as we extend to new cities or apps, we‚Äôll carry Teresa‚Äôs approach with us (e.g., each new city florist writes a personal intro for the site, the app sends a personal welcome message from Teresa when first installed, etc.). The technology‚Äôs flexibility will support the business as it blossoms, just like a well-tended garden ready for new growth.
